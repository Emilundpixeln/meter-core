import _ from"cap";import{isIPv4 as g}from"net";import{TypedEmitter as y}from"tiny-typed-emitter";import{EventEmitter as a}from"stream";var l=class extends a{sessions;device_addr;listening_port;constructor(e,t){super(),this.sessions={},this.device_addr=e,this.listening_port=t,a.call(this)}track_packet(e,t,s){let r=t.info.srcaddr+":"+s.info.srcport,n=t.info.dstaddr+":"+s.info.dstport,f;r<n?f=r+"-"+n:f=n+"-"+r;let c=!1,i=this.sessions[f];i||(c=!0,i=new d(this.device_addr,this.listening_port),this.sessions[f]=i,i.on("end",()=>{delete this.sessions[f]})),i.track(e,t,s),c&&this.emit("session",i)}},d=class extends a{state;src;dst;send_seqno;send_buffers;recv_seqno;recv_buffers;device_addr;listening_port;constructor(e,t){super(),this.device_addr=e,this.listening_port=t,this.state="NONE",this.send_seqno=0,this.send_buffers=[],this.recv_seqno=0,this.recv_buffers=[],a.call(this)}track(e,t,s){let r=t.info.srcaddr+":"+s.info.srcport,n=t.info.dstaddr+":"+s.info.dstport;this.state==="NONE"?(this.device_addr===t.info.srcaddr&&this.listening_port!==s.info.srcport?(this.src=r,this.dst=n):(this.src=n,this.dst=r),s.info.flags&2&&!(s.info.flags&16)?this.state="SYN_SENT":this.state="ESTAB"):s.info.flags&2&&!(s.info.flags&16)?this.emit("syn retry",this):this[this.state](e,t,s)}SYN_SENT(e,t,s){t.info.srcaddr+":"+s.info.srcport===this.dst&&s.info.flags&18?(this.send_seqno=s.info.ackno??0,this.state="SYN_RCVD"):s.info.flags&4&&(this.state="CLOSED",this.emit("reset",this,"recv"))}SYN_RCVD(e,t,s){t.info.srcaddr+":"+s.info.srcport===this.src&&s.info.flags&16&&(this.recv_seqno=s.info.ackno??0,this.emit("start",this),this.state="ESTAB")}ESTAB(e,t,s){let r=t.info.srcaddr+":"+s.info.srcport,n=t.info.totallen-t.hdrlen-s.hdrlen,f=!1;try{f=k(e,t,s)}catch{return}r===this.src?(n>0&&this.send_buffers.push({seqno:s.info.seqno,payload:Buffer.from(e.subarray(s.offset,s.offset+n))}),s.info.ackno&&!f&&this.flush_buffers(s.info.ackno??0,"recv"),s.info.flags&1&&(this.state="FIN_WAIT")):r===this.dst?(n>0&&this.recv_buffers.push({seqno:s.info.seqno,payload:Buffer.from(e.subarray(s.offset,s.offset+n))}),s.info.ackno&&!f&&this.flush_buffers(s.info.ackno??0,"send"),s.info.flags&1&&(this.state="CLOSE_WAIT")):console.error("non-matching packet in session: ip="+t+"tcp="+s)}FIN_WAIT(e,t,s){t.info.srcaddr+":"+s.info.srcport===this.dst&&s.info.flags&1&&(this.state="CLOSING")}CLOSE_WAIT(e,t,s){t.info.srcaddr+":"+s.info.srcport===this.src&&s.info.flags&1&&(this.state="LAST_ACK")}LAST_ACK(e,t,s){t.info.srcaddr+":"+s.info.srcport===this.dst&&(this.state="CLOSED",this.emit("end",this))}CLOSING(e,t,s){t.info.srcaddr+":"+s.info.srcport===this.src&&(this.state="CLOSED",this.emit("end",this))}CLOSED(e,t,s){}flush_buffers(e,t){if(t==="recv"){this.recv_seqno===0&&(this.recv_seqno=e);let s=this.get_flush(this.recv_buffers,this.recv_seqno,e);if(this.recv_seqno=e,!s)return;this.emit("payload_recv",s)}else if(t==="send"){this.send_seqno===0&&(this.send_seqno=e);let s=this.get_flush(this.send_buffers,this.send_seqno,e);if(this.send_seqno=e,!s)return;this.emit("payload_send",s)}}get_flush(e,t,s){let r=s-t;if(r<=0)return null;let n=Buffer.alloc(r),f=Buffer.alloc(r),c=e.filter(i=>{if(i.seqno>s)return!0;i.seqno<t&&(i.payload=i.payload.subarray(t-i.seqno),i.seqno=t);let h=i.seqno-t,u=s-i.seqno;return i.payload.copy(n,h,0,u),f.fill(1,h,h+u),u<i.payload.length?(i.payload=i.payload.subarray(u),i.seqno+=u,!0):!1});return e.length=0,e.push(...c),f.includes(0)?(console.error(`[meter-core/tcp_tracker] - Dropped ${r} bytes`),null):n}};function k(o,e,t){if(t.hdrlen==20)return!1;let s=e.offset+e.hdrlen+20,r=t.hdrlen-20,n=s+r;for(;s<n;)switch(o[s]){case 0:s=n;break;case 1:s+=1;break;case 2:s+=4;break;case 3:s+=3;break;case 4:s+=2;break;case 5:return!0;case 8:s+=10;break;case 254:case 255:s+=o[s+1]??1;break;default:throw new Error(`Unknown TCPOption ${o[s]}, packet is probably malformed, should drop.`)}return!1}var{findDevice:A,deviceList:C}=_.Cap,{Ethernet:T,PROTOCOL:m,IPV4:B,TCP:E}=_.decoders;var p=class extends y{c;#s;constructor(e,t){super(),this.c=new _.Cap,this.#s=Buffer.alloc(65535);let s=this.c.open(t,"tcp and (src port 6040 or dst port 6040)",10*1024*1024,this.#s),r=new b,n=new l(e,6040);this.c.setMinBytes&&this.c.setMinBytes(54),this.c.on("packet",(f,c)=>{if(s==="ETHERNET"){let i=T(this.#s);if(i.info.type===m.ETHERNET.IPV4){let h=B(this.#s,i.offset);if(h.info.protocol===m.IP.TCP){let u=E(this.#s,h.offset);n.track_packet(this.#s,h,u)}}}}),n.on("session",f=>{f.on("payload_recv",c=>{r.write(c);let i=r.read();for(;i;)this.emit("packet",i),i=r.read()})})}close(){this.c.close()}},v=class extends y{caps;constructor(e){super(),this.caps=new Map;for(let t of C())for(let s of t.addresses)if(g(s.addr))try{let r=new p(s.addr,t.name);r.on("packet",n=>this.emit("packet",n,t.name)),this.caps.set(t.name,r)}catch(r){e(`[meter-core/PktCaptureAll] ${r}`)}}close(){for(let e of this.caps.values())e.close()}},b=class{buffer;position;out;constructor(){this.buffer=null,this.position=0,this.out=[]}write(e){for(;e.length>0;){if(this.buffer){if(this.buffer.length<2){let r=this.buffer[0],n=(e[0]<<8)+r;this.buffer=Buffer.alloc(n),this.buffer[0]=r,this.position=1}let s=Math.min(e.length,this.buffer.length-this.position);e.copy(this.buffer,this.position,0,s),this.position+=s,this.position===this.buffer.length&&(this.out.push(this.buffer),this.buffer=null,this.position=0),e=e.subarray(s);continue}if(e.length<2){this.buffer=Buffer.from(e),this.position=e.length;break}let t=e.readUInt16LE(0);if(t>e.length){this.buffer=Buffer.alloc(t),e.copy(this.buffer),this.position=e.length;break}this.out.push(e.subarray(0,t)),e=e.subarray(t)}}read(){return this.out.shift()}};export{p as PktCapture,v as PktCaptureAll,C as deviceList,A as findDevice};
