import l from"cap";import{networkInterfaces as v}from"os";import{TypedEmitter as k}from"tiny-typed-emitter";var{findDevice:d,deviceList:P}=l.Cap,{Ethernet:E,PROTOCOL:b,IPV4:g,TCP:y}=l.decoders;var h=class extends k{c;buffer;constructor(t){super(),this.c=new l.Cap,this.buffer=Buffer.alloc(65535);let i=this.c.open(t,"tcp and src port 6040",10*1024*1024,this.buffer),e=new p;this.c.setMinBytes&&this.c.setMinBytes(6),this.c.on("packet",(s,r)=>{if(i==="ETHERNET"){let o=E(this.buffer);if(o.info.type===b.ETHERNET.IPV4){let f=g(this.buffer,o.offset);if(f.info.protocol===b.IP.TCP){let n=f.info.totallen-f.hdrlen,c=y(this.buffer,f.offset);if(n-=c.hdrlen,n){e.write(this.buffer.subarray(c.offset,c.offset+n));let u=e.read();for(;u;)this.emit("packet",u),u=e.read()}}}}})}close(){this.c.close()}},m=class extends k{caps;constructor(t=!1){super(),this.caps=new Map;for(let[i,e]of Object.entries(v()))if(e){for(let s of e)if(!(!t&&s.internal)&&s.family==="IPv4"){let r=d(s.address);if(r){let o=new h(r);o.on("packet",f=>this.emit("packet",f,i)),this.caps.set(s.address,o)}}}}close(){for(let t of this.caps.values())t.close()}},p=class{buffer;position;out;constructor(){this.buffer=null,this.position=0,this.out=[]}write(t){for(;t.length>0;){if(this.buffer){if(this.buffer.length<2){let s=this.buffer[0],r=(t[0]<<8)+s;this.buffer=Buffer.alloc(r),this.buffer[0]=s,this.position=1}let e=Math.min(t.length,this.buffer.length-this.position);t.copy(this.buffer,this.position,0,e),this.position+=e,this.position===this.buffer.length&&(this.out.push(this.buffer),this.buffer=null,this.position=0),t=t.subarray(e);continue}if(t.length<2){this.buffer=Buffer.from(t),this.position=t.length;break}let i=t.readUInt16LE(0);if(i>t.length)break;this.out.push(t.subarray(0,i)),t=t.subarray(i)}}read(){return this.out.shift()}};export{h as PktCapture,m as PktCaptureAll,P as deviceList,d as findDevice};
