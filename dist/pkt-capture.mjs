import a from"cap";import{networkInterfaces as d}from"os";import{TypedEmitter as v}from"tiny-typed-emitter";var{findDevice:E,deviceList:T}=a.Cap,{Ethernet:g,PROTOCOL:m,IPV4:y,TCP:B}=a.decoders;var p=class extends v{c;constructor(t){super(),this.c=new a.Cap;let e=Buffer.alloc(65535),i=this.c.open(t,"tcp and src port 6040",10*1024*1024,e),s=new l;this.c.setMinBytes&&this.c.setMinBytes(6),this.c.on("packet",(o,r)=>{if(i==="ETHERNET"){let f=g(e);if(f.info.type===m.ETHERNET.IPV4){let n=y(e,f.offset);if(n.info.protocol===m.IP.TCP){let c=n.info.totallen-n.hdrlen,u=B(e,n.offset);if(c-=u.hdrlen,c){s.write(Buffer.from(e.subarray(u.offset,u.offset+c)));let h=s.read();for(;h;)this.emit("packet",h),h=s.read()}}}}})}close(){this.c.close()}},k=class extends v{caps;constructor(t=!1){super(),this.caps=new Map;for(let[e,i]of Object.entries(d()))if(i){for(let s of i)if(!(!t&&s.internal)&&s.family==="IPv4"){let o=E(s.address);if(o){let r=new p(o);r.on("packet",f=>this.emit("packet",f,e)),this.caps.set(s.address,r)}}}}close(){for(let t of this.caps.values())t.close()}},l=class{buffer;position;out;constructor(){this.buffer=null,this.position=0,this.out=[]}write(t){for(;t.length>0;){if(this.buffer){if(this.buffer.length<2){let s=this.buffer[0],o=(t[0]<<8)+s;this.buffer=Buffer.alloc(o),this.buffer[0]=s,this.position=1}let i=Math.min(t.length,this.buffer.length-this.position);t.copy(this.buffer,this.position,0,i),this.position+=i,this.position===this.buffer.length&&(this.out.push(this.buffer),this.buffer=null,this.position=0),t=t.subarray(i);continue}if(t.length<2){this.buffer=Buffer.from(t),this.position=t.length;break}let e=t.readUInt16LE(0);if(e>t.length)break;this.out.push(t.subarray(0,e)),t=t.subarray(e)}}read(){return this.out.shift()}};export{p as PktCapture,k as PktCaptureAll,T as deviceList,E as findDevice};
