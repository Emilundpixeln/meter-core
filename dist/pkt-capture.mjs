import l from"cap";import{networkInterfaces as v}from"os";import{TypedEmitter as k}from"tiny-typed-emitter";var{findDevice:d,deviceList:P}=l.Cap,{Ethernet:E,PROTOCOL:b,IPV4:g,TCP:y}=l.decoders;var h=class extends k{c;buffer;constructor(e){super(),this.c=new l.Cap,this.buffer=Buffer.alloc(65535);let i=this.c.open(e,"tcp and src port 6040",10*1024*1024,this.buffer),t=new p;this.c.setMinBytes&&this.c.setMinBytes(6),this.c.on("packet",(s,r)=>{if(i==="ETHERNET"){let o=E(this.buffer);if(o.info.type===b.ETHERNET.IPV4){let f=g(this.buffer,o.offset);if(f.info.protocol===b.IP.TCP){let n=f.info.totallen-f.hdrlen,c=y(this.buffer,f.offset);if(n-=c.hdrlen,n){t.write(Buffer.from(this.buffer.subarray(c.offset,c.offset+n)));let u=t.read();for(;u;)this.emit("packet",u),u=t.read()}}}}})}close(){this.c.close()}},m=class extends k{caps;constructor(e=!1){super(),this.caps=new Map;for(let[i,t]of Object.entries(v()))if(t){for(let s of t)if(!(!e&&s.internal)&&s.family==="IPv4"){let r=d(s.address);if(r){let o=new h(r);o.on("packet",f=>this.emit("packet",f,i)),this.caps.set(s.address,o)}}}}close(){for(let e of this.caps.values())e.close()}},p=class{buffer;position;out;constructor(){this.buffer=null,this.position=0,this.out=[]}write(e){for(;e.length>0;){if(this.buffer){if(this.buffer.length<2){let s=this.buffer[0],r=(e[0]<<8)+s;this.buffer=Buffer.alloc(r),this.buffer[0]=s,this.position=1}let t=Math.min(e.length,this.buffer.length-this.position);e.copy(this.buffer,this.position,0,t),this.position+=t,this.position===this.buffer.length&&(this.out.push(this.buffer),this.buffer=null,this.position=0),e=e.subarray(t);continue}if(e.length<2){this.buffer=Buffer.from(e),this.position=e.length;break}let i=e.readUInt16LE(0);if(i>e.length)break;this.out.push(e.subarray(0,i)),e=e.subarray(i)}}read(){return this.out.shift()}};export{h as PktCapture,m as PktCaptureAll,P as deviceList,d as findDevice};
