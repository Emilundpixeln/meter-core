"use strict";var m=Object.create;var u=Object.defineProperty;var a=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var B=(e,r)=>{for(var o in r)u(e,o,{get:r[o],enumerable:!0})},f=(e,r,o,n)=>{if(r&&typeof r=="object"||typeof r=="function")for(let s of y(r))!w.call(e,s)&&s!==o&&u(e,s,{get:()=>r[s],enumerable:!(n=a(r,s))||n.enumerable});return e};var x=(e,r,o)=>(o=e!=null?m(p(e)):{},f(r||!e||!e.__esModule?u(o,"default",{value:e,enumerable:!0}):o,e)),d=e=>f(u({},"__esModule",{value:!0}),e);var g={};B(g,{Decompressor:()=>l});module.exports=d(g);var t=require("lz4-napi"),c=x(require("oodle")),i=require("snappy"),l=class{oodle;xorTable;constructor(r,o){if(this.oodle=new c.default.Oodle(r),o.length!=256)throw new Error("Invalid xorTable length");this.xorTable=o}decrypt(r,o,n,s){switch(s&&this.xor(r,o),n){case 0:return r.subarray(16);case 1:return(0,t.uncompressSync)(r).subarray(16);case 2:return(0,i.uncompressSync)(r).subarray(16);case 3:{let b=r.readUInt32LE(0),h=Buffer.alloc(b);return r=this.oodle.decode(r.subarray(4),h),r.subarray(16)}default:throw new Error(`Unknown compression: ${n}`)}}xor(r,o){for(let n=0;n<r.length;n++)r[n]^=this.xorTable[o++%256]}};0&&(module.exports={Decompressor});
